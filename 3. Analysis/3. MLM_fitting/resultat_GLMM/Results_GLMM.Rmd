---
title: "Generalized Linear Mixed Model on trail running sex-distance-level speed difference"
subtitle: 'On absolute speed pair selection'
author: "Franck LE MAT"
date: "18/01/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(data.table)
library(funModeling)
library(pander)
library(scales)
library(lme4)
library(car)
library(fitdistrplus)
library(mgcv)
library(MASS)
library(ggsci)
library(caTools)
library(glmmTMB)
library(Metrics)
library(MuMIn)

######################
## Dataset load 
######################

setwd("~/Project_LIBM/UTMB_data_mining/3. Analysis/")
race_result <- fread('DRV_result.csv')

#select_coureur_relatif <- fread('3. MLM_fitting/pair_MLM_4%_unique.csv')
select_coureur_absolue <- fread('3. MLM_fitting/pair_MLM_60s_unique.csv')

######################
## Variable encoding
######################

df <- inner_join(race_result,
                 select_coureur_absolue,
                 by = c("id_course_annee", "id_coureur"))

# # Add for relatif only !!!!!!!!!!!!!!!!
# df <- df %>%
#   filter((id_pair != 639) & (id_pair != 214))
# ------------------------------------------

df <- df %>%
  group_by(id_coureur,annee) %>%
  mutate(id_coureur_annee = cur_group_id()) %>%
  ungroup() %>%
  transform(id_coureur_annee = as.factor(id_coureur_annee),
            id_course_annee = as.factor(id_course_annee),
            id_pair = as.factor(id_pair),
            sexe = as.factor(sexe))

```


## Creation of classement variable (level)

This chukc of code shows how the level classification have been done. 

```{r variable creation}

class_building <- function(x){
  
  # We select 'short' distance race, meaning race from 25 to 45 km effort
  df_rank <- x %>%
    filter(km_effort >= 25 & km_effort <= 45) %>%
    group_by(id_pair) %>%
    summarise(vitesse_moy_kmE = mean(km_effort)/mean(temps_s/3600), 
              vitesse_moy = mean(vitesse_moy), 
              km_effort = mean(km_effort))
  
  # We create a linear model with those race's speed 
  l_model <- lm(vitesse_moy_kmE ~ km_effort, data = df_rank)
  
  # We adjust the speed in function of the beta coefficient of the linear model
  rank <- df_rank %>% 
    mutate(vitesse_moy_adj = (l_model$coefficients[2]
                              * (km_effort - min(km_effort)))
           + vitesse_moy_kmE)
  
  # We calculate the quartile of the adjuted speed.
  # Each quartile represent a level classification 
  rank <- rank %>%
    mutate(class = cut(x = vitesse_moy_adj, 
                       breaks = quantile(rank$vitesse_moy_adj,
                                         probs = seq(0, 1, 1/4)), 
                       labels = c("Q4", "Q3", "Q2", "Q1"), 
                       include.lowest = TRUE)) %>%
    dplyr::select("id_pair", "class") %>%
    distinct()
  
  x <- x %>%
    inner_join(rank, by = "id_pair")
  return(x)
}

df <- class_building(df)

```


## Visualisation of speed vs km effort

```{r viz, echo = FALSE}

ggplot(df,
       aes(x = km_effort,
           y = vitesse_moy,
           color = sexe)) +
  geom_point(alpha = .5,
             size = 1) +
  scale_x_continuous(breaks =  breaks_pretty()) +
  scale_y_continuous(breaks = breaks_pretty()) +
  scale_color_lancet()+
  labs(y = "Speed (km/h)", 
       x = "km effort (a.u.)", 
       title = "Selected pair using relative speed") +
  theme_classic() + 
  facet_wrap(~class)

```

## Dataset description

```{r description, echo = FALSE}
df_describe <- df %>%
  dplyr::select('id_coureur_annee', 'id_course_annee', 'km_effort', 'cote', 'age', 'vitesse_moy', 'class')
pander(summary(df_describe))

description <- df %>%
  group_by(class,sexe) %>%
  summarise(nbr_runner = n(), 
            mean_speed = paste(round(mean(vitesse_moy, na.rm = TRUE), 2), '+/-', round(sd(vitesse_moy), 2)), 
            median_rank_scratch = median(place, na.rm = TRUE), 
            mean_cote = paste(round(mean(cote, na.rm = TRUE), 2), '+/-', round(sd(cote, na.rm = TRUE), 2)), 
            age = paste(round(mean(age, na.rm = TRUE), 2), '+/-', round(sd(age), 2)), 
            .groups = 'drop')
pander(description, caption = "relative selection dataset description")

```

## Distribution evaluation of speed variable

```{r distr}
plotdist(df$vitesse_moy)

descdist(df$vitesse_moy, boot = 100) 

dist_plot <- function(data){
  fg <- fitdist(data,"gamma")
  fln <- fitdist(data,"lnorm")
  fn <- fitdist(data,"norm")
  par(mfrow=c(2, 2))
  denscomp(list(fn,fln,fg), legendtext=c("normal", "lognormal", "gamma"))
  qqcomp(list(fn,fln,fg), legendtext=c("normal", "lognormal", "gamma"))
  cdfcomp(list(fn,fln,fg), legendtext=c("normal", "lognormal", "gamma"))
  ppcomp(list(fn,fln,fg), legendtext=c("normal", "lognormal", "gamma"))
}

dist_plot(df$vitesse_moy)
```

The evaluation of the distribution shows that average speed follows a gamma distribution. For the GLMM model we will use a gamma model with log link function.

## Random effect selection

We first selected the random effect as suggested by Zuur and al. (2009). 

```{r random}
# gamma_glmm1 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_coureur_annee),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))
# 
# 
# gamma_glmm2 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_course_annee),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))
# 
# gamma_glmm3 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_pair),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))
# 
# gamma_glmm4 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_coureur_annee) 
#                        + (1| id_pair),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))
# 
# gamma_glmm5 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_pair) 
#                        + (1| id_course_annee),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))
# 
# 
# gamma_glmm6 <- glmmTMB(vitesse_moy ~ km_effort*sexe*class  
#                        + (1|id_coureur_annee) 
#                        + (1| id_course_annee),
#                        data = df, 
#                        family=Gamma(link="log"), 
#                        control = glmmTMBControl(parallel = 7))

gamma_glmm7 <- glmmTMB(vitesse_moy ~ km_effort + sexe + class + km_effort:sexe + km_effort:class + km_effort:sexe:class
                       + (1|id_coureur_annee)  
                       + (1|id_pair)
                       + (1|id_course_annee),
                       data = df, 
                       family=Gamma(link="log"), 
                       control = glmmTMBControl(parallel = 7))


summary(gamma_glmm7)
```

```{r random2, echo=FALSE}
# aic_value <- AIC(gamma_glmm1,
#                  gamma_glmm2,
#                  gamma_glmm3,
#                  gamma_glmm4,
#                  gamma_glmm5,
#                  gamma_glmm6,
#                  gamma_glmm7)
# 
# aic_value$model <- rownames(aic_value)
# 
# ggplot(aic_value, aes(x = model,
#                       y = AIC)) + 
#   geom_bar(stat = 'identity',
#            fill = 'steelblue') + 
#   geom_text(aes(label = round(AIC, 2)),
#             vjust = -.5)+
#   scale_y_continuous(breaks = breaks_pretty()) +
#   scale_color_lancet()+
#   theme_classic() 

```

## Fixed effect selection

We then evaluate fixed effects.

```{r fixed}
model <- gamma_glmm7

library(parallel)

# clusterType <- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
# clust <- try(makeCluster(getOption("cl.cores", 7), type = clusterType))
# 
# clusterExport(clust, c("glmmTMB",
#                        'glmmTMBControl',
#                        'df'))
# invisible(clusterCall(clust,
#                       "library",
#                       "stats4",
#                       character.only = TRUE))
# 
# options(na.action = "na.fail")
# model_dredge<- MuMIn::pdredge(cluster = clust,
#                               global.model = model,
#                               rank = "AIC")
# 
# stopCluster(clust)
# 
# print(model_dredge)


```

The model with the lowest AIC is the model: vitesse_moy ~ km_effort : sexe : class  + (1|id_coureur_annee) + (1|id_pair) + (1|id_course_annee)

## Model evaluation 

```{r eval2}
library(DHARMa)

simulationOutput <- simulateResiduals(fittedModel = model, plot = F)


plot(simulationOutput)

```

This plot show significant effect of overdispersion however this is surely due to data size. See below dispersion test :

```{r eval3}

testDispersion(simulationOutput)

testOutliers(simulationOutput)

r.squaredGLMM(model)

```


```{r eval4, echo = FALSE}
re <- ranef(model)$cond$id_coureur_annee
qqnorm(re$`(Intercept)`,
       main = 'Normal Q-Q Plot of runner random effect')
qqline(re$`(Intercept)`)

re <- ranef(model)$cond$id_pair
qqnorm(re$`(Intercept)`,
       main = 'Normal Q-Q Plot of pair random effect')
qqline(re$`(Intercept)`)


re <- ranef(model)$cond$id_course_annee
qqnorm(re$`(Intercept)`,
       main = 'Normal Q-Q Plot of race random effect')
qqline(re$`(Intercept)`)

```

We can observe on the two plots above that outliers of both random effects on intercept move away from normality.

## Results visualisation 
```{r result viz}
library(ggeffects)
mydf <- ggpredict(model,
                  terms = c("km_effort", "sexe"))

ggplot(mydf,
       aes(x,
           predicted)) +
  geom_line(aes(colour = group)) +
  geom_ribbon(aes(ymin = conf.low,
                  ymax = conf.high,
                  fill = group), 
              alpha = .1,
              show.legend=FALSE) + 
  labs(
    y = "Speed (km/h)",
    x = "km effort (a.u.)",
    colour = "Gender",
    title = "Marginal effect of sexe and km effort on speed"
  ) +
  scale_x_continuous(breaks = pretty_breaks()) + 
  scale_y_continuous(breaks = pretty_breaks()) +
  scale_fill_lancet() +
  scale_color_lancet() +
  theme_classic() 

```

```{r result viz2}
library(ggeffects)
mydf <- ggpredict(model,
                  terms = c("km_effort", "sexe", "class"))

ggplot(mydf,
       aes(x,
           predicted)) +
  geom_line(aes(colour = group)) +
  geom_ribbon(aes(ymin = conf.low,
                  ymax = conf.high,
                  fill = group),
              alpha = .1,
              show.legend=FALSE) + 
  labs(
    y = "Speed (km/h)",
    x = "km effort (a.u.)",
    colour = "Gender",
    title = "Marginal effect of sexe, km effort and level on speed"
  ) +
  scale_x_continuous(breaks = pretty_breaks()) + 
  scale_y_continuous(breaks = pretty_breaks()) +
  scale_color_lancet() +
  scale_fill_lancet() +
  theme_classic() +
  facet_wrap(~facet)

equation = 'Q4'
a_f = model$fit$par[1]
b_f = model$fit$par[2]


a_h = model$fit$par[1] + model$fit$par[3]
b_h = model$fit$par[2] + model$fit$par[7]


print(paste0('eq:', equation, '-vit_F = exp(',round(a_f, 5), round(b_f, 5),' x kme)'))
print(paste0('eq:', equation, '-vit_H = exp(',round(a_h, 5), round(b_h, 5),' x kme)'))
print('-----------------')
  
for(n in c(0:2)){

  equation = paste0('Q',2-n)
  
  a_f = model$fit$par[1] + model$fit$par[4+n]
  b_f = model$fit$par[2] + model$fit$par[8+n]
  
  
  a_h = model$fit$par[1] + model$fit$par[4+n] + model$fit$par[3] + model$fit$par[11+n]
  b_h = model$fit$par[2] + model$fit$par[8+n] + model$fit$par[7] + model$fit$par[14+n]
  
  
  print(paste0('eq:', equation, '-vit_F = exp(',round(a_f, 5), round(b_f, 5),' x kme)'))
  print(paste0('eq:', equation, '-vit_H = exp(',round(a_h, 5), round(b_h, 5),' x kme)'))
  print('-----------------')
}

```
# Confidance intervals
```{r confint}
# summary(model)
# 
# clusterType <- if(length(find.package("snow", quiet = TRUE))) "SOCK" else "PSOCK"
# clust <- try(makeCluster(getOption("cl.cores", 7), type = clusterType))
# 
# clusterExport(clust, c("glmmTMB",
#                        'glmmTMBControl',
#                        'data'))
# invisible(clusterCall(clust,
#                       "library",
#                       "stats4",
#                       character.only = TRUE))
# 
# model_profil <- profile(model,
#                         parallel = 'multicore',
#                         cl = clust)
# 
# stopCluster(clust)
# 
# confint(model_profil)


confint(model)


```
# Contrasts
```{r contrast}
library(emmeans)

emm <- emmeans(model, pairwise~sexe|km_effort*class,
               type = "response",
               at = list(km_effort = seq(25, 260, by = 25)))
ss <- summary(emm)

ss
contrast_plot <- function(x, cl) {
  max_ratio <- max(x$ratio) * 1.05
  min_ratio <- min(x$ratio) * 0.95
  
  max_p <- max(x$p.value) * 1.05
  min_p <- min(x$p.value) * 0.95
  
  contrast_plot <- split(x = as.data.table(x) %>% 
                           filter(class %in% cl) %>%
                           mutate(class = droplevels(class)), by ="class")

  plot <- lapply(seq_along(contrast_plot), function(x){
    contrast_plot[[x]] %>%
      ggplot(aes(x = as.numeric(km_effort),
                 y = ratio)) +
      geom_ribbon(aes(ymin= ratio - SE,
                      ymax= ratio + SE),
                  alpha = .5,
                  color = 'grey') +
      geom_line(group = 1) + 
      geom_hline(yintercept = 1) +
      scale_y_continuous(breaks = pretty_breaks(),
                         limits = c(min_ratio, max_ratio)) + 
      scale_x_continuous(breaks = pretty_breaks())+
      labs(x = NULL,
           y = NULL) + 
      theme_bw() + 
      theme(plot.title = element_text(size=10))
  })
  plot <- ggpubr::ggarrange(plotlist = plot, ncol = 1, align = 'hv',
                            labels = rep(cl), label.x = 0.1)


  plot_p <- lapply(seq_along(contrast_plot), function(x){
    contrast_plot[[x]] %>%
      ggplot(aes(x = as.numeric(km_effort),
                 y = p.value)) +
      geom_line(group = 1, color = 'red') + 
      scale_y_continuous(breaks = pretty_breaks(),
                         limits = c(min_p, max_p)) + 
      scale_x_continuous(breaks = pretty_breaks())+
      labs(x = NULL,
           y = NULL) + 
      theme_bw() + 
      theme(plot.title = element_text(size=10))
  })
  plot_p <- ggpubr::ggarrange(plotlist = plot_p, ncol = 1, align = 'hv')

  figure <- ggpubr::ggarrange(plot, plot_p, ncol = 2, align = 'hv')

  ggpubr::annotate_figure(figure,
                  bottom = ggpubr::text_grob("km effort (a. u.)", size = 14),
                  left = ggpubr::text_grob("Ratio speed F/M", rot = 90, size = 14),
                  right = ggpubr::text_grob("Ratio p-value", rot = 90, size = 14),
  )
}

contrast_plot(ss$contrasts, cl = c("Q1", "Q2"))
contrast_plot(ss$contrasts, cl = c("Q3", "Q4"))


emt1 <- emtrends(model, specs = ~sexe , var = "km_effort", type = 'predict')
ss2
ss2 <- summary(emt1)
ss2_contraste <- summary(pairs(emt1))[c(1, 14, 23, 28), ] %>%
  mutate(class = c("Q4", "Q3", "Q2", "Q1"))
# VarCorr(model)
# SDtot = sqrt(0.017143 + 0.079930 + 0.163683)
# df.residual(model)
# 
# emmV <- emmeans(model, ~ sexe|km_effort*class)
# eff_size(emt1, edf=df.residual(model), sigma = SDtot, method = 'eff')
# ?eff_size
ggplot(ss2, aes(x = class, y = km_effort.trend)) + 
  geom_point(aes(color = sexe), size = 4, position = position_dodge(.3)) + 
  geom_errorbar(position = position_dodge(.3),
                aes(ymin = lower.CL, ymax = upper.CL, color = sexe), 
                width=0.2, size=.5) +
  geom_text(data = ss2_contraste,
                           aes(x = class,
                               label = paste("p-value =",
                                             formatC(p.value, format = 'e')),
                               y = -0.002),
            size = 2.5) +
  labs(x = 'Level', 
       y = 'global km effort estimate') + 
  scale_y_continuous(breaks = pretty_breaks()) +
  scale_color_lancet() +
  theme_classic()
```